#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0, rgba8) uniform image2D image;
layout(binding = 3, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(location = 0) rayPayloadEXT vec3 hitColor;

layout(push_constant) uniform PushConstants {
    float time;
    uint debugMask;
    float distance;
    float yaw;
    float pitch;
    float fov;
} pc;

void main() {
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;
    d.x *= float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);
    
    // Camera setup using spherical coordinates
    const float GRID_SIZE = 256.0;
    vec3 target = vec3(GRID_SIZE * 0.5);
    
    float cy = cos(pc.yaw);
    float sy = sin(pc.yaw);
    float cp = cos(pc.pitch);
    float sp = sin(pc.pitch);
    
    vec3 camPos = target + pc.distance * vec3(cy * cp, sp, sy * cp);
    vec3 forward = normalize(target - camPos);
    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
    vec3 up = cross(right, forward);
    
    float tanHalfFov = tan(radians(pc.fov) * 0.5);
    vec3 rayDir = normalize(forward + tanHalfFov * (d.x * right + d.y * up));
    
    // Trace ray
    hitColor = vec3(0.0);
    
    traceRayEXT(topLevelAS,              // acceleration structure
                gl_RayFlagsOpaqueEXT,     // ray flags
                0xFF,                      // cull mask
                0,                         // sbt record offset
                0,                         // sbt record stride
                0,                         // miss index
                camPos,                    // ray origin
                0.001,                     // ray min range
                rayDir,                    // ray direction
                10000.0,                   // ray max range
                0);                        // payload location
    
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(hitColor, 1.0));
}

